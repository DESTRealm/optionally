<?php

namespace DESTRealm\Optionally;

use DESTRealm\Optionally\Getopt\Getopt;
use DESTRealm\Optionally\Options;
use DESTRealm\Optionally\Exceptions\OptionsException;
use DESTRealm\Optionally\Exceptions\OptionsValueException;

/**
 * Option builder.
 *
 * This class generates option data used by the Options object. Default values,
 * special cases, filters, and aliases are handled here.
 */
class OptionBuilder
{
    /**
     * Non-optional command line arguments. Note that this shares a similar name
     * with the $args value that's passed in to OptionBuilder::buildOptions()
     * but is not the same value.
     * @var array
     */
    private $args = array();

    /**
     * Getopt instance.
     * @var Getopt
     */
    private $getopt = null;

    /**
     * Help instance.
     * @var Help
     */
    private $help = null;

    /**
     * Options, values, defaults, settings and aliases.
     * @var array
     */
    private $options = array();

    /**
     * Option map.
     * @var array
     */
    private $optionMap = array();

    /**
     * Option builder factory method.
     * @param  array $args Bare script args minus the script name.
     * @param  array $options Options, defaults, settings, and aliases.
     * @param  array $map Option map; maps option aliases to their "master"
     * values.
     * @param  Help $help Generated help object. This is passed as is to
     * Options.
     * @return Options Returns a generated instance of Options.
     */
    public static function buildOptions ($args, $options, $map, $help)
    {
        $builder = new self($options, $map);
        $options = $builder->build($args);

        return new Options($options, $builder->getArgs(), $help);
    } // end buildOptions ()

    /**
     * Constructor.
     * @param array $options Option settings, defaults, and aliases.
     * @param array $map     Option map, mapping aliases to their "master"
     * values.
     */
    private function __construct ($options, $map)
    {
        $this->getopt = new Getopt();
        $this->options = $options;
        $this->optionMap = $map;
    } // end constructor

    /**
     * Build options and returns a list suitable for the Options object. Built
     * options contain all aliases and mangled names assigned to their
     * respective values.
     * @param  array $args Bare args, minus the name of the currently running
     * script, for Getopt usage.
     * @return array Returns an array containing a map of all command line
     * options (and their aliases) to their values.
     */
    public function build ($args)
    {
        $getopt = $this->parseOptions($args);

        $args = $getopt[1];
        $options = $getopt[0];

        $this->args = $args;

        $parsedOptions = $this->assignValues(
            $options,
            $this->options
        );

        return $this->buildAliases($this->evaluateOptions($parsedOptions));

    } // end build ()

    /**
     * Retrieves the arguments generated by Getopt.
     * @return array Returns the non-optional arguments gathered by Getopt.
     */
    public function getArgs () { return $this->args; }

    /**
     * Accepts the output from Getopt and assigns values accordingly. Values
     * are rearranged according to their master option name (no aliases will
     * appear in the returned value), how many times they've appeared, and their
     * value.
     * @param array $options Getopt options.
     * @return array Returns an array containing the following:
     *
     * array(
     *   'option_name' => array(
     *     'count' => number_of_appearances,
     *     'value' => array(val1, val2, ..., valn+1) OR null
     *   )
     * )
     *
     * If the option isn't a value option or had no value specified, the "value"
     * offset will be null, even if further instances of the same option are
     * provided. The "value" offset is appended to in order of the options'
     * appearance.
     */
    private function assignValues ($options)
    {
        $values = array();

        foreach ($options as $option) {

            $opt = $option[0]; // Option name.
            $val = $option[1]; // Option value. Might be empty.

            // Filter long options.
            $opt = str_replace('--', '', $opt);

            // Force all options to their master name.
            $opt = $this->optionMap[$opt];

            // Empty arguments to Getopt options are set to false by default.
            // We correct that here.
            if ($val === false) {
                $val = null;
            }

            if (!array_key_exists($opt, $values)) {

                if ($val !== null) {
                    $val = array($val);
                }

                $values[$opt] = array(
                    'count' => 1,
                    'value' => $val,
                );

            } else {

                $values[$opt]['count'] += 1;

                // Empy current and former values imply we've nothing to do.
                if ($val === null && $values[$opt]['value'] === null) {
                    continue;
                }

                // We've snagged a value of some sort. If the previous one was
                // null, we convert it to an array and slap the current value
                // in there.
                if ($val !== null) {
                    if ($values[$opt]['value'] === null) {
                        $values[$opt]['value'] = array($val);
                    } else {
                        $values[$opt]['value'][] = $val;
                    }
                }

            }

        }

        return $values;
    } // end assignValues ()

    /**
     * Builds aliases for the evaluated values $values.
     * @param  array $values Evaluated values.
     * @return array         Evaluated values plus aliases.
     */
    private function buildAliases ($values)
    {
        foreach ($this->optionMap as $option => $master) {

            $aliases = array_merge(
                $this->mangle($master),
                $this->mangle($option)
            );

            foreach ($aliases as $alias) {

                // Don't overwrite aliases that already exist. If they do,
                // there's likely a name collision somewhere and we should bail
                // out.
                if (array_key_exists($alias, $values)) {
                    continue;
                }

                $values[$alias] =& $values[$master];

            }

        }

        return $values;
    } // end buildAliases ()

    /**
     * Evaluated the parsed options and their values or counts as appropriate.
     * @param  array $parsed Parsed options.
     * @return array Evaluated options.
     */
    private function evaluateOptions ($parsed)
    {
        $evaluated = array();

        foreach ($this->options as $option => $defaults) {

            // Default value assignments. If the default value is specified,
            // all options are assigned this at first, and then overwritten if
            // the option was provided.
            if ($defaults['defaults'] !== null) {
                $evaluated[$option] = $defaults['defaults'];
            }

            // Handle required options.
            if ($defaults['required'] && !array_key_exists($option, $parsed)) {
                throw new OptionsException(
                    sprintf(
                        'Required option "%s" was not provided!',
                        $option
                    )
                );
            }

            // Value assignments; first, values are assigned if the option was
            // specified, and second if the options were not.
            if (array_key_exists($option, $parsed)) {

                $value = $parsed[$option]['value'];

                // Boolean values. This will immediately bail on match.
                if ($defaults['boolean']) {
                    $evaluated[$option] = true;
                    continue;
                }

                // Countable options.
                if ($defaults['isCountable']) {
                    $evaluated[$option] = $parsed[$option]['count'];
                }

                // Array options.
                if ($defaults['isArray']) {
                    if (!empty($value)) {
                        $evaluated[$option] = (array)$value;
                    } else {
                        $evaluated[$option] = null;
                    }
                    $evaluated = $this->runFilters($option, $defaults,
                        $evaluated);
                    continue;
                }

                if (empty($value)) {
                    // This code is never executed because Getopt will throw
                    // an exception before required values can be handled here.
                    // However, because current plans are to replace Getopt
                    // with Optionally-specific code, this is being retained.
                    /*if (!$defaults['optionalValue']) {
                        throw new OptionsException(
                            sprintf(
                                'Option %s requires a value!',
                                $option
                            )
                        );
                    }*/
                    $evaluated = $this->runFilters($option, $defaults,
                        $evaluated);
                    continue;
                }

                // Set value if we haven't already bailed out.
                $evaluated[$option] = $value[count($value)-1];

            } else {

                // Boolean values. This will immediately bail on match.
                if ($defaults['boolean']) {
                    $evaluated[$option] = false;
                    continue;
                }

                // Default value assignment, if the option is missing. This
                // requires using defaultsIfMissing().
                if ($defaults['ifMissing'] !== null) {
                    $evaluated[$option] = $defaults['ifMissing'];
                }

                // Countable options.
                if ($defaults['isCountable']) {
                    $evaluated[$option] = 0;
                }

                // Array options.
                if ($defaults['isArray']) {
                    $evaluated[$option] = array();
                }
            }

            $evaluated = $this->runFilters($option, $defaults, $evaluated);
        }

        return $evaluated;
    } // end evaluateOptions ()

    /**
     * Retrieves a Getopt suffix for the option $option. Single letter options
     * will return a suffix of ":" while word options will return a suffix of
     * "=". Suffixes are returned only if $hasValue is true; double-suffixes
     * will be returned if both $hasValue is true and $optional is true.
     * @param  string  $option         Option.
     * @param  boolean $hasValue=false Option requests a value.
     * @param  boolean $optional=false Option requests an optional value.
     * @return string Empty string, ":", "::", "=", or "==".
     */
    private function getSuffixForOption ($option)
    {
        $optional  = $this->options[ $this->optionMap[$option] ]['optionalValue'];
        $boolean   = $this->options[ $this->optionMap[$option] ]['boolean'];
        $countable = $this->options[ $this->optionMap[$option] ]['isCountable'];
        $suffix = '';

        if ($boolean || $countable) {
            return '';
        }

        if (strlen($option) === 1) {

            if ($optional) {
                $suffix = '::';
            } else {
                $suffix = ':';
            }

        } else {

            if ($optional) {
                $suffix = '==';
            } else {
                $suffix = '=';
            }

        }

        return $suffix;
    } // end getSuffixForOption ()

    /**
     * Mangles an option name if it contains a dash (-) such that it's
     * accessible as a PHP property.
     * @param  string $name Option name.
     * @return array       Array containing mangled names.
     */
    private function mangle ($name)
    {
        if (strpos($name, '-') === false) {
            return array($name);
        }

        $parts = explode('-', $name);
        $underscoreAlias = implode('_', $parts);


        $first = array_shift($parts);
        $rest = array_map('ucfirst', $parts);
        $camelCaseAlias = $first.implode('', $rest);

        return array($name, $underscoreAlias, $camelCaseAlias);
    } // end mangle ()

    /**
     * Parses the options' settings and generates a list of short- and long-args
     * for Getopt. $args and each of the parsed configurations are then passed
     * into Getopt which returns a list of options it discovered and non-
     * optional command line arguments.
     * @param  array $args Bare command line arguments, minus the script name.
     * @return array Getopt-parsed options.
     */
    private function parseOptions ($args)
    {
        $shortOpts = '';
        $longOpts = array();

        /**
         * Appends the appropriate suffix to either $shortOpts or $longOpts.
         */
        $appendOpts = function ($option, $suffix) use (&$shortOpts, &$longOpts) {
            if (strlen($option) === 1) {
                $shortOpts .= $option.$suffix;
            } else {
                $longOpts[] = $option.$suffix;
            }

        };
        // Figure out which options have values or optional values.
        foreach ($this->optionMap as $option => $master) {

            $appendOpts($option, $this->getSuffixForOption($option));

        }

        return $this->getopt->getopt2(
            $args,
            $shortOpts,
            $longOpts,
            true
        );
    } // end parseArgs ()

    /**
     * Run filters.
     * @param  string $option    Option name.
     * @param  array $defaults  Default settings for the current option.
     * @param  array $evaluated Evaluated values.
     * @return array Returns updated, evaluated values.
     */
    private function runFilters ($option, $defaults, $evaluated)
    {
        if (empty($defaults['filter'])) {
            return $evaluated;
        }

        $callback = $defaults['filter'];

        $value = null;

        if (array_key_exists($option, $evaluated)) {
            $value = $evaluated[$option];
        }

        // test() was triggered on this option.
        if ($defaults['isTest']) {

            $callbackRunner = function ($callback, $value) use ($defaults) {
                // If test() fails, we'll first set the option's value
                // to filterValue if it's set or defaults. If defaults
                // isn't set either, we'll raise an exception.
                if (!call_user_func($callback, $value)) {
                    if ($defaults['filterValue'] !== null) {
                        return $defaults['filterValue'];
                    } else if ($defaults['defaults'] !== null) {
                        return $defaults['defaults'];
                    } else {
                        throw new OptionsValueException(
                            sprintf(
                                'Invalid value "%s".',
                                print_r($value, true)
                            )
                        );
                    }
                }

                return $value;
            }; // end callbackRunner ()

        } else {

            $callbackRunner = function ($callback, $value) {
                // filter() is much simpler than test(); we simply
                // return whatever it returns.
                return call_user_func($callback, $value);
            }; // end callbackRunner ()

        }

        // Now, we'll examine $value to see if it's an array or a
        // scalar.
        if ((array)$value !== $value) {
            $evaluated[$option] = $callbackRunner($callback, $value);
        } else {
            $newValue = array();
            foreach ($value as $element) {
                $element = $callbackRunner($callback, $element);
                $newValue[] = $element;
            }
            $evaluated[$option] = $newValue;
        }

        return $evaluated;
    } // end runFilters ()
} // end OptionBuilder